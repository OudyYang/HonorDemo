class Player < ActiveRecord::Base

	def self.find_or_create(player_name)
		player = Player.where(name: player_name).first
		if !player.nil?
			return player
		end
		player = Player.new
		player.name = player_name
		player.save
		
		# Reload so that the player_id is set.
		Player.where(name: player_name).first
	end
	
	# Returns the mutual honor object if it's made. Nil otherwise.
	def send_honor(to, champion, probability)
		honor = Honor.where(from: self.player_id, to: to).first
		if honor.nil?
			honor = Honor.new
			honor.from = self.player_id
			honor.to = to
		end
		honor.timestamp = Time.now
		honor.champion = champion
		honor.probability = probability
		
		mutual_honor = nil
		if rand(2) < 1
			mutual_honor = self.chance_for_mutual(to, champion, probability)
			honor.seen = 1
		else
			honor.seen = 0
		end
		honor.save
		mutual_honor
	end
	
	# Returns the mutual honor object if it's made. Nil otherwise.
	def chance_for_mutual(to, champion, probability)
		output = nil
		if rand < probability
			mutual_honor = MutualHonor.where(from: self.player_id, to: to).first
			if mutual_honor.nil?
				mutual_honor = MutualHonor.new
				mutual_honor.from = self.player_id
				mutual_honor.to = to
			end
			mutual_honor.champion = champion
			mutual_honor.timestamp = Time.now
			mutual_honor.save
			
			# Reload to ensure that the autogenerated id is filled.
			output = MutualHonor.where(from: self.player_id, to: to).includes(:from_object, :to_object, :champion_object).first
		end
		output
	end
	
	# Returns an array of successful mutual honors
	def chance_old_honor
		honors = Honor.where(from: self.player_id).where(seen: 0)
		mutual_honors = Array.new
		honors.each do |honor|
			honor.seen = 1;
			honor.save
			mutual_honor = self.chance_for_mutual(honor.to, honor.champion, honor.probability)
			unless mutual_honor.nil?
				mutual_honors.push(mutual_honor)
			end
		end
		mutual_honors
	end
	
	def find_honored(npcs)
		npc_ids = npcs.collect{|x| x.npc_id}
		honors = Honor.where(from: self.player_id, to: npc_ids)
		honors.collect{|x| x.to}.to_set
	end
	
	def generate_room
		output = Array.new
		recent = MutualHonor.where(from: self.player_id).where('timestamp > ?', 30.seconds.ago).includes(:to_object).order('RAND()')
		old = MutualHonor.where(from: self.player_id).where('timestamp <= ?', 30.seconds.ago).includes(:to_object).order('RAND()').first(4)
		index = 0
		while output.length < 4 && index < recent.size
			if rand(2) < 1
				mutual_honor = recent[index]
				output.push(mutual_honor.to_object)
				mutual_honor.timestamp = Time.now
				mutual_honor.save
			end
			index += 1
		end
		current_size = output.length
		(current_size..3).each do |n|
			if old.length > 0 && rand(10) < 1
				mutual_honor = old.shift
				output.push(mutual_honor.to_object)
				mutual_honor.timestamp = Time.now
				mutual_honor.save
			end
		end
		remaining = 9 - output.length
		
		npc_names = output.collect{|x| x.name}
		output = output + Npc.get_random(remaining, self.name, npc_names)
		
		# Shuffle blue side so the honored aren't always on the top.
		output[0..3].shuffle + output[4..8]
	end
	
end